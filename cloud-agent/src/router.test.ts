import { beforeEach, describe, expect, it, vi } from 'vitest';
import { TRPCError } from '@trpc/server';
import * as z from 'zod';

// Mock Cloudflare sandbox to prevent module resolution errors
vi.mock('@cloudflare/sandbox', () => ({
  getSandbox: vi.fn(),
}));

const { interruptMock, buildContextMock, getOrCreateSessionMock } = vi.hoisted(() => ({
  interruptMock: vi.fn(),
  buildContextMock: vi.fn(),
  getOrCreateSessionMock: vi.fn(),
}));

const { getSandboxIdForSessionMock, metadataMock } = vi.hoisted(() => ({
  getSandboxIdForSessionMock: vi.fn(),
  metadataMock: vi.fn(),
}));

vi.mock('./session-service.js', () => ({
  generateSessionId: vi.fn(() => 'agent_12345678-1234-1234-1234-123456789abc'),
  fetchSessionMetadata: vi.fn(),
  InvalidSessionMetadataError: class InvalidSessionMetadataError extends Error {
    constructor(
      public readonly userId: string,
      public readonly sessionId: string,
      public readonly details?: string
    ) {
      super(`Invalid session metadata for session ${sessionId}`);
      this.name = 'InvalidSessionMetadataError';
    }
  },
  SessionService: class SessionService {
    constructor() {
      this.buildContext = buildContextMock;
      this.getOrCreateSession = getOrCreateSessionMock;
      this.getSandboxIdForSession = getSandboxIdForSessionMock;
    }
    buildContext!: typeof buildContextMock;
    getOrCreateSession!: typeof getOrCreateSessionMock;
    getSandboxIdForSession!: typeof getSandboxIdForSessionMock;
    get metadata() {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      return metadataMock();
    }
    static interrupt = interruptMock;
  },
}));

import { getSandbox } from '@cloudflare/sandbox';
import { generateSessionId, fetchSessionMetadata } from './session-service.js';
import { sessionIdSchema, envVarsSchema } from './types.js';
import { appRouter } from './router.js';
import type { TRPCContext, SessionId } from './types.js';
import type { CloudAgentSessionState } from './persistence/types.js';

type MockCAS = {
  idFromName: ReturnType<typeof vi.fn>;
  get: ReturnType<typeof vi.fn>;
};

// Note: Balance validation is now handled in the worker entry point (index.ts)
// via pre-flight validation before the tRPC handler is called.
// This returns proper HTTP status codes (401, 402) instead of SSE error events.
// See cloud-agent/src/balance-validation.ts for the implementation.
// Tests for balance validation are in cloud-agent/src/balance-validation.test.ts

describe('router sessionId validation', () => {
  it('should reject invalid session ID formats', () => {
    const invalidIds = [
      // Path traversal and command injection
      'agent_../../etc/passwd',
      'agent_abc123; rm -rf /',
      '../agent_12345678-1234-1234-1234-123456789abc',
      // Missing or wrong prefix
      'session_12345678-1234-1234-1234-123456789abc',
      '12345678-1234-1234-1234-123456789abc',
      // Incomplete formats
      'agent_',
      'agent_incomplete',
      '',
      // Special characters
      'agent_test%00null',
      'agent_<script>alert(1)</script>',
      // Non-hex characters in UUID
      'agent_xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx',
      'agent_ZZZZZZZZ-ZZZZ-ZZZZ-ZZZZ-ZZZZZZZZZZZZ',
      // Wrong UUID length/format
      'agent_12345678-1234-1234-1234-123456789ab',
      'agent_123456781234123412341234567890abc',
      // Whitespace/extra characters
      'agent_12345678-1234-1234-1234-123456789abc ',
      ' agent_12345678-1234-1234-1234-123456789abc',
    ];

    for (const invalidId of invalidIds) {
      const result = sessionIdSchema.safeParse(invalidId);
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues[0]?.message).toBe('Invalid session ID format');
      }
    }
  });

  it('should accept valid session ID formats', () => {
    const validIds = [
      'agent_12345678-1234-1234-1234-123456789abc',
      'agent_00000000-0000-0000-0000-000000000000',
      'agent_ffffffff-ffff-ffff-ffff-ffffffffffff',
      'agent_ABCDEF01-2345-6789-ABCD-EF0123456789', // Case-insensitive
      'agent_Abcd1234-5678-90AB-cdef-0123456789aB', // Mixed case
    ];

    for (const validId of validIds) {
      const result = sessionIdSchema.safeParse(validId);
      expect(result.success).toBe(true);
    }
  });

  it('should accept session IDs generated by generateSessionId()', () => {
    const generatedId = generateSessionId();
    const result = sessionIdSchema.safeParse(generatedId);
    expect(result.success).toBe(true);
  });

  describe('envVars validation', () => {
    it('should reject HOME variable', () => {
      const result = envVarsSchema.safeParse({ HOME: '/custom/home' });
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues[0]?.message).toContain('reserved environment variables');
        expect(result.error.issues[0]?.message).toContain('HOME');
      }
    });

    it('should reject SESSION_ID variable', () => {
      const result = envVarsSchema.safeParse({ SESSION_ID: 'custom-id' });
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues[0]?.message).toContain('reserved environment variables');
        expect(result.error.issues[0]?.message).toContain('SESSION_ID');
      }
    });

    it('should reject SESSION_HOME variable', () => {
      const result = envVarsSchema.safeParse({ SESSION_HOME: '/custom/session' });
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues[0]?.message).toContain('reserved environment variables');
        expect(result.error.issues[0]?.message).toContain('SESSION_HOME');
      }
    });

    it('should reject multiple reserved variables', () => {
      const result = envVarsSchema.safeParse({
        HOME: '/custom/home',
        SESSION_ID: 'custom-id',
        API_KEY: 'valid-key',
      });
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues[0]?.message).toContain('reserved environment variables');
      }
    });

    it('should allow non-reserved variables', () => {
      const result = envVarsSchema.safeParse({
        API_KEY: 'my-api-key',
        DATABASE_URL: 'postgresql://localhost:5432/mydb',
        NODE_ENV: 'production',
        CUSTOM_VAR: 'custom-value',
      });
      expect(result.success).toBe(true);
    });

    it('should reject undefined (schema requires actual object)', () => {
      // The envVarsSchema itself requires an object when used
      // Optionality is handled at the parent schema level
      const result = envVarsSchema.safeParse(undefined);
      expect(result.success).toBe(false);
    });

    it('should allow empty env vars object', () => {
      const result = envVarsSchema.safeParse({});
      expect(result.success).toBe(true);
    });
  });

  describe('sandboxId generation with hash format', () => {
    describe('format validation', () => {
      it('should generate sandboxId with org prefix for organization accounts', async () => {
        const { generateSandboxId } = await import('./sandbox-id.js');
        const sandboxId = await generateSandboxId('org-123', 'user-456');
        expect(sandboxId).toMatch(/^org-[0-9a-f]{48}$/);
        expect(sandboxId.length).toBe(52);
      });

      it('should generate sandboxId with bot prefix when botId is provided', async () => {
        const { generateSandboxId } = await import('./sandbox-id.js');
        const sandboxId = await generateSandboxId('org-123', 'user-456', 'reviewer');
        expect(sandboxId).toMatch(/^bot-[0-9a-f]{48}$/);
        expect(sandboxId.length).toBe(52);
      });
    });

    describe('personal accounts', () => {
      it('should generate sandboxId with usr prefix for personal accounts', async () => {
        const { generateSandboxId } = await import('./sandbox-id.js');
        const sandboxId = await generateSandboxId(undefined, 'abc-123');
        expect(sandboxId).toMatch(/^usr-[0-9a-f]{48}$/);
        expect(sandboxId.length).toBe(52);
      });

      it('should generate sandboxId with ubt prefix for personal bot accounts', async () => {
        const { generateSandboxId } = await import('./sandbox-id.js');
        const sandboxId = await generateSandboxId(undefined, 'abc-123', 'reviewer');
        expect(sandboxId).toMatch(/^ubt-[0-9a-f]{48}$/);
        expect(sandboxId.length).toBe(52);
      });
    });

    describe('collision prevention', () => {
      it('should prevent collision between org and personal accounts', async () => {
        const { generateSandboxId } = await import('./sandbox-id.js');
        const userId = 'same-user-id';

        const orgSandboxId = await generateSandboxId('org-123', userId);
        const personalSandboxId = await generateSandboxId(undefined, userId);

        expect(orgSandboxId).not.toBe(personalSandboxId);
        expect(orgSandboxId).toMatch(/^org-[0-9a-f]{48}$/);
        expect(personalSandboxId).toMatch(/^usr-[0-9a-f]{48}$/);
      });

      describe('deleteSession procedure', () => {
        let mockContext: TRPCContext;
        let mockSandbox: ReturnType<typeof getSandbox>;
        let caller: ReturnType<typeof appRouter.createCaller>;
        let cloudAgentSession: MockCAS;

        beforeEach(() => {
          vi.clearAllMocks();
          interruptMock.mockResolvedValue({
            success: true,
            killedProcessIds: ['p1'],
            failedProcessIds: [],
            message: 'stopped',
          });
          buildContextMock.mockImplementation(({ sandboxId, orgId, userId, sessionId }) => ({
            sandboxId,
            orgId,
            userId,
            sessionId,
            sessionHome: `/home/${sessionId}`,
            workspacePath: `/workspace/${sessionId}`,
            branchName: `session/${sessionId}`,
          }));
          const mockSession = { token: 'session' };
          getOrCreateSessionMock.mockResolvedValue(mockSession);

          // Mock context
          mockContext = {
            userId: 'test-user-123',
            authToken: 'test-token',
            botId: undefined,
            request: {} as Request,
            env: {
              Sandbox: {} as TRPCContext['env']['Sandbox'],
              CLOUD_AGENT_SESSION: {
                idFromName: vi.fn(id => ({ id })),
                get: vi.fn(() => ({
                  deleteSession: vi.fn().mockResolvedValue(undefined),
                  markAsInterrupted: vi.fn().mockResolvedValue(undefined),
                  getActiveExecutionId: vi.fn().mockResolvedValue(null),
                  getExecution: vi.fn().mockResolvedValue(null),
                  getQueuedCount: vi.fn().mockReturnValue(0),
                  enqueueExecution: vi.fn().mockResolvedValue({ status: 'started' }),
                })),
              } as unknown as TRPCContext['env']['CLOUD_AGENT_SESSION'],
              EXECUTION_QUEUE: {
                send: vi.fn().mockResolvedValue(undefined),
              } as unknown as TRPCContext['env']['EXECUTION_QUEUE'],
              NEXTAUTH_SECRET: 'test-secret',
            },
          };
          cloudAgentSession = mockContext.env.CLOUD_AGENT_SESSION as unknown as MockCAS;

          // Mock sandbox with deleteSession method
          mockSandbox = {
            deleteSession: vi.fn().mockResolvedValue(undefined),
          } as unknown as ReturnType<typeof getSandbox>;

          vi.mocked(getSandbox).mockReturnValue(mockSandbox);

          // Create caller with mocked context
          caller = appRouter.createCaller(mockContext);
        });

        describe('successful deletion', () => {
          it('should successfully delete existing session', async () => {
            const sessionId: SessionId = 'agent_12345678-1234-1234-1234-123456789abc';
            const metadata: CloudAgentSessionState = {
              version: 123456789,
              sessionId,
              orgId: 'org-123',
              userId: 'test-user-123',
              timestamp: 123456789,
            };

            vi.mocked(fetchSessionMetadata).mockResolvedValue(metadata);
            const deleteSessionMock = vi.fn().mockResolvedValue(undefined);
            vi.mocked(cloudAgentSession.get).mockReturnValue({
              deleteSession: deleteSessionMock,
              markAsInterrupted: vi.fn().mockResolvedValue(undefined),
            });

            const result = await caller.deleteSession({ sessionId });

            expect(result).toEqual({ success: true });
            expect(fetchSessionMetadata).toHaveBeenCalledWith(
              mockContext.env,
              'test-user-123',
              sessionId
            );
            expect(getSandbox).toHaveBeenCalledWith(
              mockContext.env.Sandbox,
              expect.stringMatching(/^org-[0-9a-f]{48}$/)
            );
            // eslint-disable-next-line @typescript-eslint/unbound-method
            const sandboxDelete = vi.mocked(mockSandbox.deleteSession);
            expect(sandboxDelete).toHaveBeenCalledWith(sessionId);
            expect(cloudAgentSession.idFromName).toHaveBeenCalledWith(
              `${metadata.userId}:${sessionId}`
            );
            expect(deleteSessionMock).toHaveBeenCalled();
          });

          it('should successfully delete session for personal account', async () => {
            const sessionId: SessionId = 'agent_abcdef01-2345-6789-abcd-ef0123456789';
            const metadata: CloudAgentSessionState = {
              version: 123456789,
              sessionId,
              orgId: undefined, // Personal account
              userId: 'test-user-123',
              timestamp: 123456789,
            };

            vi.mocked(fetchSessionMetadata).mockResolvedValue(metadata);

            const result = await caller.deleteSession({ sessionId });

            expect(result).toEqual({ success: true });
            // Should use usr prefix for personal accounts
            expect(getSandbox).toHaveBeenCalledWith(
              mockContext.env.Sandbox,
              expect.stringMatching(/^usr-[0-9a-f]{48}$/)
            );
          });

          it('should successfully delete session with botId', async () => {
            const sessionId: SessionId = 'agent_11111111-2222-3333-4444-555555555555';
            const metadata: CloudAgentSessionState = {
              version: 123456789,
              sessionId,
              orgId: 'org-123',
              userId: 'test-user-123',
              timestamp: 123456789,
              botId: 'reviewer',
            };

            vi.mocked(fetchSessionMetadata).mockResolvedValue(metadata);

            const result = await caller.deleteSession({ sessionId });

            expect(result).toEqual({ success: true });
            // Should include bot suffix
            expect(getSandbox).toHaveBeenCalledWith(
              mockContext.env.Sandbox,
              expect.stringMatching(/^bot-[0-9a-f]{48}$/)
            );
          });
        });

        describe('idempotency', () => {
          it('should return success for non-existent session', async () => {
            const sessionId: SessionId = 'agent_00000000-0000-0000-0000-000000000000';

            vi.mocked(fetchSessionMetadata).mockResolvedValue(null);

            const result = await caller.deleteSession({ sessionId });

            expect(result).toEqual({
              success: true,
              message: 'Session not found or already deleted',
            });
            // Should not attempt to delete from sandbox or destroy session
            expect(getSandbox).not.toHaveBeenCalled();
            expect(cloudAgentSession.get).not.toHaveBeenCalled();
          });
        });

        describe('sandbox deletion failure handling', () => {
          it('should continue cleanup when sandbox deletion fails', async () => {
            const sessionId: SessionId = 'agent_aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee';
            const metadata: CloudAgentSessionState = {
              version: 123456789,
              sessionId,
              orgId: 'org-123',
              userId: 'test-user-123',
              timestamp: 123456789,
            };

            vi.mocked(fetchSessionMetadata).mockResolvedValue(metadata);
            // Sandbox deletion fails
            mockSandbox.deleteSession = vi.fn().mockRejectedValue(new Error('Sandbox unreachable'));
            // DO cleanup succeeds
            const deleteSessionMock = vi.mocked(cloudAgentSession.get).mockReturnValue({
              deleteSession: vi.fn().mockResolvedValue(undefined),
              markAsInterrupted: vi.fn().mockResolvedValue(undefined),
            });

            const result = await caller.deleteSession({ sessionId });

            // Should still succeed overall
            expect(result).toEqual({ success: true });
            // Should have attempted both cleanups
            // eslint-disable-next-line @typescript-eslint/unbound-method
            const sandboxDelete = vi.mocked(mockSandbox.deleteSession);
            expect(sandboxDelete).toHaveBeenCalled();
            expect(deleteSessionMock().deleteSession).toHaveBeenCalled();
          });
        });

        describe('DO cleanup failure handling', () => {
          it('should fail when DO cleanup fails', async () => {
            const sessionId: SessionId = 'agent_ffffffff-ffff-ffff-ffff-ffffffffffff';
            const metadata: CloudAgentSessionState = {
              version: 123456789,
              sessionId,
              orgId: 'org-123',
              userId: 'test-user-123',
              timestamp: 123456789,
            };

            vi.mocked(fetchSessionMetadata).mockResolvedValue(metadata);
            const deleteSessionMock = vi.mocked(cloudAgentSession.get).mockReturnValue({
              deleteSession: vi.fn().mockRejectedValue(new Error('connection lost')),
              markAsInterrupted: vi.fn().mockResolvedValue(undefined),
            });

            await expect(caller.deleteSession({ sessionId })).rejects.toThrow(TRPCError);
            await expect(caller.deleteSession({ sessionId })).rejects.toThrow(
              'Failed to clean up session metadata'
            );
            expect(deleteSessionMock().deleteSession).toHaveBeenCalled();
          });

          it('should succeed when DO cleanup succeeds', async () => {
            const sessionId: SessionId = 'agent_11111111-1111-1111-1111-111111111111';
            const metadata: CloudAgentSessionState = {
              version: 123456789,
              sessionId,
              orgId: 'org-123',
              userId: 'test-user-123',
              timestamp: 123456789,
            };

            vi.mocked(fetchSessionMetadata).mockResolvedValue(metadata);
            const deleteSessionMock = vi.mocked(cloudAgentSession.get).mockReturnValue({
              deleteSession: vi.fn().mockResolvedValue(undefined),
              markAsInterrupted: vi.fn().mockResolvedValue(undefined),
            });

            const result = await caller.deleteSession({ sessionId });

            // Should still succeed overall - partial cleanup is acceptable
            expect(result).toEqual({ success: true });
            expect(deleteSessionMock().deleteSession).toHaveBeenCalled();
          });

          it('should succeed when DO cleanup succeeds (no partial R2 path)', async () => {
            const sessionId: SessionId = 'agent_22222222-2222-2222-2222-222222222222';
            const metadata: CloudAgentSessionState = {
              version: 123456789,
              sessionId,
              orgId: 'org-123',
              userId: 'test-user-123',
              timestamp: 123456789,
            };

            vi.mocked(fetchSessionMetadata).mockResolvedValue(metadata);
            const deleteSessionMock = vi.mocked(cloudAgentSession.get).mockReturnValue({
              deleteSession: vi.fn().mockResolvedValue(undefined),
              markAsInterrupted: vi.fn().mockResolvedValue(undefined),
            });

            const result = await caller.deleteSession({ sessionId });

            // Should still succeed overall - partial cleanup is acceptable
            expect(result).toEqual({ success: true });
            expect(deleteSessionMock().deleteSession).toHaveBeenCalled();
          });
        });

        describe('authorization', () => {
          it('should require authentication', async () => {
            const unauthenticatedContext: TRPCContext = {
              userId: undefined,
              authToken: undefined,
              botId: undefined,
              env: mockContext.env,
            } as unknown as TRPCContext;

            const unauthenticatedCaller = appRouter.createCaller(unauthenticatedContext);

            await expect(
              unauthenticatedCaller.deleteSession({ sessionId: 'agent_test' })
            ).rejects.toThrow('Authentication required');
          });

          it('should only allow users to delete their own sessions', async () => {
            const sessionId: SessionId = 'agent_99999999-8888-7777-6666-555555555555';

            // fetchSessionMetadata is called with the requesting user's ID
            // It will return null or throw if the user doesn't own the session
            vi.mocked(fetchSessionMetadata).mockResolvedValue(null);

            const result = await caller.deleteSession({ sessionId });

            // Should treat as non-existent (user can't access other user's sessions)
            expect(result).toEqual({
              success: true,
              message: 'Session not found or already deleted',
            });
          });
        });

        describe('error handling', () => {
          it('should handle metadata fetch errors', async () => {
            const sessionId: SessionId = 'agent_deadbeef-dead-beef-dead-beefdeadbeef';

            vi.mocked(fetchSessionMetadata).mockRejectedValue(new Error('Metadata fetch failed'));

            await expect(caller.deleteSession({ sessionId })).rejects.toThrow(TRPCError);
            await expect(caller.deleteSession({ sessionId })).rejects.toThrow(
              'Failed to delete session'
            );
          });

          it('should wrap non-TRPCError errors', async () => {
            const sessionId: SessionId = 'agent_cafebabe-cafe-babe-cafe-babecafebabe';

            vi.mocked(fetchSessionMetadata).mockRejectedValue(new Error('Generic error'));

            await expect(caller.deleteSession({ sessionId })).rejects.toThrow(TRPCError);

            try {
              await caller.deleteSession({ sessionId });
            } catch (error) {
              expect(error).toBeInstanceOf(TRPCError);
              expect((error as TRPCError).code).toBe('INTERNAL_SERVER_ERROR');
            }
          });

          it('should preserve TRPCError instances', async () => {
            const sessionId: SessionId = 'agent_facefeed-face-feed-face-feedfacefeed';
            const originalError = new TRPCError({
              code: 'PRECONDITION_FAILED',
              message: 'Session metadata is invalid',
            });

            vi.mocked(fetchSessionMetadata).mockRejectedValue(originalError);

            await expect(caller.deleteSession({ sessionId })).rejects.toThrow(originalError);
          });
        });
      });

      it('should prevent collision between user and bot sessions', async () => {
        const { generateSandboxId } = await import('./sandbox-id.js');
        const orgId = 'org-123';
        const userId = 'user-456';
        const botId = 'reviewer';

        const userSandboxId = await generateSandboxId(orgId, userId);
        const botSandboxId = await generateSandboxId(orgId, userId, botId);

        expect(userSandboxId).not.toBe(botSandboxId);
        expect(userSandboxId).toMatch(/^org-[0-9a-f]{48}$/);
        expect(botSandboxId).toMatch(/^bot-[0-9a-f]{48}$/);
      });
    });

    describe('getSessionLogs procedure', () => {
      let mockContext: TRPCContext;
      let mockSandbox: ReturnType<typeof getSandbox>;
      let caller: ReturnType<typeof appRouter.createCaller>;
      let mockSession: { readFile: ReturnType<typeof vi.fn> };

      beforeEach(() => {
        vi.clearAllMocks();

        // Mock session with readFile method
        mockSession = {
          readFile: vi.fn(),
        };

        // Mock context
        mockContext = {
          userId: 'test-user-123',
          authToken: 'test-token',
          botId: undefined,
          request: {} as Request,
          env: {
            Sandbox: {} as TRPCContext['env']['Sandbox'],
            CLOUD_AGENT_SESSION: {
              idFromName: vi.fn(id => ({ id })),
              get: vi.fn(() => ({
                deleteSession: vi.fn().mockResolvedValue(undefined),
                markAsInterrupted: vi.fn().mockResolvedValue(undefined),
                getActiveExecutionId: vi.fn().mockResolvedValue(null),
                getExecution: vi.fn().mockResolvedValue(null),
                getQueuedCount: vi.fn().mockReturnValue(0),
                enqueueExecution: vi.fn().mockResolvedValue({ status: 'started' }),
              })),
            } as unknown as TRPCContext['env']['CLOUD_AGENT_SESSION'],
            EXECUTION_QUEUE: {
              send: vi.fn().mockResolvedValue(undefined),
            } as unknown as TRPCContext['env']['EXECUTION_QUEUE'],
            NEXTAUTH_SECRET: 'test-secret',
          },
        };

        // Mock sandbox
        mockSandbox = {
          deleteSession: vi.fn().mockResolvedValue(undefined),
        } as unknown as ReturnType<typeof getSandbox>;

        vi.mocked(getSandbox).mockReturnValue(mockSandbox);

        // Mock buildContext
        buildContextMock.mockImplementation(({ sandboxId, orgId, userId, sessionId }) => ({
          sandboxId,
          orgId,
          userId,
          sessionId,
          sessionHome: `/home/${sessionId as string}`,
          workspacePath: `/workspace/${sessionId as string}`,
          branchName: `session/${sessionId as string}`,
        }));

        // Mock getOrCreateSession to return our mock session
        getOrCreateSessionMock.mockResolvedValue(mockSession);

        // Create caller with mocked context
        caller = appRouter.createCaller(mockContext);
      });

      describe('successful retrieval', () => {
        it('should return log content for valid session', async () => {
          const sessionId: SessionId = 'agent_12345678-1234-1234-1234-123456789abc';
          const logContent = 'Test log content\nLine 2\nLine 3';

          // Mock getSandboxIdForSession to return sandboxId
          getSandboxIdForSessionMock.mockResolvedValue(
            'org-66323dd2584e8d815b1c6ba390a891b60488530d5a27a740'
          );

          // Mock metadata getter
          metadataMock.mockReturnValue({
            orgId: 'org-123',
            botId: undefined,
          });

          // Mock readFile to return content
          mockSession.readFile.mockResolvedValue({
            content: logContent,
            encoding: 'utf-8',
          });

          const result = await caller.getSessionLogs({ sessionId });

          expect(result).toEqual({
            content: logContent,
            sessionId,
          });
          expect(getSandboxIdForSessionMock).toHaveBeenCalledWith(
            mockContext.env,
            'test-user-123',
            sessionId
          );
          expect(mockSession.readFile).toHaveBeenCalledWith(
            `/home/${sessionId}/.kilocode/cli/logs/cli.txt`,
            { encoding: 'utf-8' }
          );
        });

        it('should work for personal account sessions', async () => {
          const sessionId: SessionId = 'agent_abcdef01-2345-6789-abcd-ef0123456789';
          const logContent = 'Personal account log';

          getSandboxIdForSessionMock.mockResolvedValue(
            'usr-1e416fe995239a134f92eec1ecc488606163bdc6a38a4cd1'
          );
          metadataMock.mockReturnValue({
            orgId: undefined,
            botId: undefined,
          });
          mockSession.readFile.mockResolvedValue({
            content: logContent,
            encoding: 'utf-8',
          });

          const result = await caller.getSessionLogs({ sessionId });

          expect(result).toEqual({
            content: logContent,
            sessionId,
          });
        });
      });

      describe('session not found', () => {
        it('should return NOT_FOUND when session does not exist', async () => {
          const sessionId: SessionId = 'agent_00000000-0000-0000-0000-000000000000';

          getSandboxIdForSessionMock.mockRejectedValue(
            new TRPCError({
              code: 'NOT_FOUND',
              message: `Session ${sessionId} not found. Please initiate a new session.`,
            })
          );

          await expect(caller.getSessionLogs({ sessionId })).rejects.toThrow(TRPCError);
          await expect(caller.getSessionLogs({ sessionId })).rejects.toThrow('not found');
        });
      });

      describe('log file not found', () => {
        it('should return NOT_FOUND when log file does not exist', async () => {
          const sessionId: SessionId = 'agent_11111111-1111-1111-1111-111111111111';

          getSandboxIdForSessionMock.mockResolvedValue(
            'org-66323dd2584e8d815b1c6ba390a891b60488530d5a27a740'
          );
          metadataMock.mockReturnValue({ orgId: 'org-123' });

          // Mock readFile to throw ENOENT error
          mockSession.readFile.mockRejectedValue(new Error('ENOENT: no such file or directory'));

          await expect(caller.getSessionLogs({ sessionId })).rejects.toThrow(TRPCError);
          await expect(caller.getSessionLogs({ sessionId })).rejects.toThrow('No log file found');
        });
      });

      describe('authorization', () => {
        it('should require authentication', async () => {
          const unauthenticatedContext: TRPCContext = {
            userId: undefined,
            authToken: undefined,
            botId: undefined,
            env: mockContext.env,
          } as unknown as TRPCContext;

          const unauthenticatedCaller = appRouter.createCaller(unauthenticatedContext);

          await expect(
            unauthenticatedCaller.getSessionLogs({
              sessionId: 'agent_12345678-1234-1234-1234-123456789abc',
            })
          ).rejects.toThrow('Authentication required');
        });
      });

      describe('error handling', () => {
        it('should handle read errors', async () => {
          const sessionId: SessionId = 'agent_22222222-2222-2222-2222-222222222222';

          getSandboxIdForSessionMock.mockResolvedValue(
            'org-66323dd2584e8d815b1c6ba390a891b60488530d5a27a740'
          );
          metadataMock.mockReturnValue({ orgId: 'org-123' });

          // Mock readFile to throw generic error
          mockSession.readFile.mockRejectedValue(new Error('Permission denied'));

          await expect(caller.getSessionLogs({ sessionId })).rejects.toThrow(TRPCError);
          await expect(caller.getSessionLogs({ sessionId })).rejects.toThrow(
            'Failed to read log file'
          );
        });

        it('should preserve TRPCError instances', async () => {
          const sessionId: SessionId = 'agent_33333333-3333-3333-3333-333333333333';
          const originalError = new TRPCError({
            code: 'PRECONDITION_FAILED',
            message: 'Session metadata is invalid',
          });

          getSandboxIdForSessionMock.mockRejectedValue(originalError);

          await expect(caller.getSessionLogs({ sessionId })).rejects.toThrow(originalError);
        });
      });
    });

    describe('getSession procedure', () => {
      let mockContext: TRPCContext;
      let caller: ReturnType<typeof appRouter.createCaller>;
      let cloudAgentSession: MockCAS;
      let mockGetMetadata: ReturnType<typeof vi.fn>;

      beforeEach(() => {
        vi.clearAllMocks();

        mockGetMetadata = vi.fn();

        // Mock context
        mockContext = {
          userId: 'test-user-123',
          authToken: 'test-token',
          botId: undefined,
          request: {} as Request,
          env: {
            Sandbox: {} as TRPCContext['env']['Sandbox'],
            CLOUD_AGENT_SESSION: {
              idFromName: vi.fn(id => ({ id })),
              get: vi.fn(() => ({
                getMetadata: mockGetMetadata,
                getActiveExecutionId: vi.fn().mockResolvedValue(null),
                getExecution: vi.fn().mockResolvedValue(null),
                getQueuedCount: vi.fn().mockReturnValue(0),
                enqueueExecution: vi.fn().mockResolvedValue({ status: 'started' }),
              })),
            } as unknown as TRPCContext['env']['CLOUD_AGENT_SESSION'],
            EXECUTION_QUEUE: {
              send: vi.fn().mockResolvedValue(undefined),
            } as unknown as TRPCContext['env']['EXECUTION_QUEUE'],
            NEXTAUTH_SECRET: 'test-secret',
          },
        };
        cloudAgentSession = mockContext.env.CLOUD_AGENT_SESSION as unknown as MockCAS;

        // Create caller with mocked context
        caller = appRouter.createCaller(mockContext);
      });

      describe('successful retrieval', () => {
        it('should return sanitized session metadata for owner', async () => {
          const sessionId: SessionId = 'agent_12345678-1234-1234-1234-123456789abc';
          const metadata: CloudAgentSessionState = {
            version: 123456789,
            sessionId,
            orgId: 'org-123',
            userId: 'test-user-123',
            timestamp: 123456789,
            kiloSessionId: 'a0000000-0000-4000-8000-000000000001',
            githubRepo: 'acme/repo',
            githubToken: 'secret-token-should-not-be-returned',
            gitUrl: undefined,
            gitToken: undefined,
            prompt: 'Build a feature',
            mode: 'code',
            model: 'claude-3-sonnet',
            autoCommit: true,
            upstreamBranch: 'main',
            envVars: { API_KEY: 'secret-value', DB_URL: 'postgres://localhost' },
            setupCommands: ['npm install', 'npm run build'],
            mcpServers: {
              puppeteer: { command: 'npx', args: ['-y', '@mcp/puppeteer'] },
            },
            preparedAt: 1700000000000,
            initiatedAt: 1700000001000,
          };

          mockGetMetadata.mockResolvedValue(metadata);

          const result = await caller.getSession({ cloudAgentSessionId: sessionId });

          // Verify the result contains safe fields
          expect(result.sessionId).toBe(sessionId);
          expect(result.kiloSessionId).toBe('a0000000-0000-4000-8000-000000000001');
          expect(result.userId).toBe('test-user-123');
          expect(result.orgId).toBe('org-123');
          expect(result.githubRepo).toBe('acme/repo');
          expect(result.prompt).toBe('Build a feature');
          expect(result.mode).toBe('code');
          expect(result.model).toBe('claude-3-sonnet');
          expect(result.autoCommit).toBe(true);
          expect(result.upstreamBranch).toBe('main');
          expect(result.preparedAt).toBe(1700000000000);
          expect(result.initiatedAt).toBe(1700000001000);
          expect(result.timestamp).toBe(123456789);
          expect(result.version).toBe(123456789);

          // Verify counts are returned, not actual values
          expect(result.envVarCount).toBe(2);
          expect(result.setupCommandCount).toBe(2);
          expect(result.mcpServerCount).toBe(1);

          // Verify secrets are NOT returned
          expect(result).not.toHaveProperty('githubToken');
          expect(result).not.toHaveProperty('gitToken');
          expect(result).not.toHaveProperty('envVars');
          expect(result).not.toHaveProperty('setupCommands');
          expect(result).not.toHaveProperty('mcpServers');

          // Verify DO was accessed with correct key
          expect(cloudAgentSession.idFromName).toHaveBeenCalledWith(`test-user-123:${sessionId}`);
        });

        it('should work for personal account sessions (no orgId)', async () => {
          const sessionId: SessionId = 'agent_abcdef01-2345-6789-abcd-ef0123456789';
          const metadata: CloudAgentSessionState = {
            version: 123456789,
            sessionId,
            orgId: undefined, // Personal account
            userId: 'test-user-123',
            timestamp: 123456789,
            prompt: 'Test prompt',
            mode: 'architect',
            model: 'gpt-4',
          };

          mockGetMetadata.mockResolvedValue(metadata);

          const result = await caller.getSession({ cloudAgentSessionId: sessionId });

          expect(result.sessionId).toBe(sessionId);
          expect(result.orgId).toBeUndefined();
          expect(result.mode).toBe('architect');
        });

        it('should handle session with no optional fields', async () => {
          const sessionId: SessionId = 'agent_11111111-1111-1111-1111-111111111111';
          const metadata: CloudAgentSessionState = {
            version: 123456789,
            sessionId,
            userId: 'test-user-123',
            timestamp: 123456789,
          };

          mockGetMetadata.mockResolvedValue(metadata);

          const result = await caller.getSession({ cloudAgentSessionId: sessionId });

          expect(result.sessionId).toBe(sessionId);
          expect(result.kiloSessionId).toBeUndefined();
          expect(result.orgId).toBeUndefined();
          expect(result.githubRepo).toBeUndefined();
          expect(result.prompt).toBeUndefined();
          expect(result.mode).toBeUndefined();
          expect(result.model).toBeUndefined();
          expect(result.autoCommit).toBeUndefined();
          expect(result.preparedAt).toBeUndefined();
          expect(result.initiatedAt).toBeUndefined();
          expect(result.envVarCount).toBeUndefined();
          expect(result.setupCommandCount).toBeUndefined();
          expect(result.mcpServerCount).toBeUndefined();
        });
      });

      describe('not found', () => {
        it('should return NOT_FOUND for non-existent session', async () => {
          const sessionId: SessionId = 'agent_00000000-0000-0000-0000-000000000000';

          mockGetMetadata.mockResolvedValue(null);

          await expect(caller.getSession({ cloudAgentSessionId: sessionId })).rejects.toThrow(
            TRPCError
          );
          await expect(caller.getSession({ cloudAgentSessionId: sessionId })).rejects.toThrow(
            'Session not found'
          );
        });
      });

      describe('cross-user access prevention', () => {
        it('should isolate sessions by userId via DO key', async () => {
          const sessionId: SessionId = 'agent_22222222-2222-2222-2222-222222222222';
          // Even if metadata exists for another user, the DO key includes userId
          // so user A cannot access user B's session

          // The DO is keyed by userId:sessionId, so a different user would get
          // a different DO instance that returns null
          mockGetMetadata.mockResolvedValue(null);

          await expect(caller.getSession({ cloudAgentSessionId: sessionId })).rejects.toThrow(
            'Session not found'
          );

          // Verify the DO was keyed with the authenticated user's ID
          expect(cloudAgentSession.idFromName).toHaveBeenCalledWith(`test-user-123:${sessionId}`);
        });
      });

      describe('lifecycle timestamps', () => {
        it('should return preparedAt when session is prepared but not initiated', async () => {
          const sessionId: SessionId = 'agent_33333333-3333-3333-3333-333333333333';
          const metadata: CloudAgentSessionState = {
            version: 123456789,
            sessionId,
            userId: 'test-user-123',
            timestamp: 123456789,
            preparedAt: 1700000000000,
            // initiatedAt is undefined - not yet initiated
          };

          mockGetMetadata.mockResolvedValue(metadata);

          const result = await caller.getSession({ cloudAgentSessionId: sessionId });

          expect(result.preparedAt).toBe(1700000000000);
          expect(result.initiatedAt).toBeUndefined();
        });

        it('should return both preparedAt and initiatedAt when session is initiated', async () => {
          const sessionId: SessionId = 'agent_44444444-4444-4444-4444-444444444444';
          const metadata: CloudAgentSessionState = {
            version: 123456789,
            sessionId,
            userId: 'test-user-123',
            timestamp: 123456789,
            preparedAt: 1700000000000,
            initiatedAt: 1700000001000,
          };

          mockGetMetadata.mockResolvedValue(metadata);

          const result = await caller.getSession({ cloudAgentSessionId: sessionId });

          expect(result.preparedAt).toBe(1700000000000);
          expect(result.initiatedAt).toBe(1700000001000);
        });
      });

      describe('authorization', () => {
        it('should require authentication', async () => {
          const unauthenticatedContext: TRPCContext = {
            userId: undefined,
            authToken: undefined,
            botId: undefined,
            env: mockContext.env,
          } as unknown as TRPCContext;

          const unauthenticatedCaller = appRouter.createCaller(unauthenticatedContext);

          await expect(
            unauthenticatedCaller.getSession({
              cloudAgentSessionId: 'agent_12345678-1234-1234-1234-123456789abc',
            })
          ).rejects.toThrow('Authentication required');
        });
      });
    });
  });

  describe('initiateFromKilocodeSession input validation', () => {
    // Create the schema matching the router's InitiateFromKiloSessionInput
    const InitiateFromKiloSessionInput = z.object({
      kiloSessionId: z.string().uuid(),
      githubRepo: z.string().regex(/^[a-zA-Z0-9_.-]+\/[a-zA-Z0-9_.-]+$/),
      prompt: z.string().min(1),
      mode: z.enum(['architect', 'code', 'ask', 'debug', 'orchestrator']),
      model: z.string().min(1),
    });

    it('should require kiloSessionId to be a valid UUID', () => {
      // Invalid UUID formats
      const invalidIds = [
        'not-a-uuid',
        '12345',
        'agent_12345678-1234-1234-1234-123456789abc', // agent_ prefix not valid for kilo session
        '',
        '12345678-1234-1234-1234-12345678', // too short
      ];

      for (const invalidId of invalidIds) {
        const result = InitiateFromKiloSessionInput.safeParse({
          kiloSessionId: invalidId,
          githubRepo: 'acme/repo',
          prompt: 'Test prompt',
          mode: 'code',
          model: 'claude-3',
        });
        expect(result.success).toBe(false);
      }

      // Valid UUID
      const validResult = InitiateFromKiloSessionInput.safeParse({
        kiloSessionId: '123e4567-e89b-12d3-a456-426614174000',
        githubRepo: 'acme/repo',
        prompt: 'Test prompt',
        mode: 'code',
        model: 'claude-3',
      });
      expect(validResult.success).toBe(true);
    });

    it('should require githubRepo in org/repo format', () => {
      // Invalid formats
      const invalidRepos = ['just-repo', '', 'https://github.com/acme/repo', 'acme/repo/extra'];

      for (const invalidRepo of invalidRepos) {
        const result = InitiateFromKiloSessionInput.safeParse({
          kiloSessionId: '123e4567-e89b-12d3-a456-426614174000',
          githubRepo: invalidRepo,
          prompt: 'Test prompt',
          mode: 'code',
          model: 'claude-3',
        });
        expect(result.success).toBe(false);
      }

      // Valid org/repo format
      const validResult = InitiateFromKiloSessionInput.safeParse({
        kiloSessionId: '123e4567-e89b-12d3-a456-426614174000',
        githubRepo: 'facebook/react',
        prompt: 'Test prompt',
        mode: 'code',
        model: 'claude-3',
      });
      expect(validResult.success).toBe(true);
    });

    it('should require prompt and mode', () => {
      // Missing prompt
      const missingPrompt = InitiateFromKiloSessionInput.safeParse({
        kiloSessionId: '123e4567-e89b-12d3-a456-426614174000',
        githubRepo: 'acme/repo',
        mode: 'code',
        model: 'claude-3',
      });
      expect(missingPrompt.success).toBe(false);

      // Empty prompt
      const emptyPrompt = InitiateFromKiloSessionInput.safeParse({
        kiloSessionId: '123e4567-e89b-12d3-a456-426614174000',
        githubRepo: 'acme/repo',
        prompt: '',
        mode: 'code',
        model: 'claude-3',
      });
      expect(emptyPrompt.success).toBe(false);

      // Invalid mode
      const invalidMode = InitiateFromKiloSessionInput.safeParse({
        kiloSessionId: '123e4567-e89b-12d3-a456-426614174000',
        githubRepo: 'acme/repo',
        prompt: 'Test prompt',
        mode: 'invalid-mode',
        model: 'claude-3',
      });
      expect(invalidMode.success).toBe(false);
    });

    it('should not include upstreamBranch parameter', () => {
      // Input with upstreamBranch should be stripped (using strict would fail)
      const result = InitiateFromKiloSessionInput.safeParse({
        kiloSessionId: '123e4567-e89b-12d3-a456-426614174000',
        githubRepo: 'acme/repo',
        prompt: 'Test prompt',
        mode: 'code',
        model: 'claude-3',
        upstreamBranch: 'feature/branch', // This should be ignored
      });
      expect(result.success).toBe(true);
      // The parsed data should not include upstreamBranch
      if (result.success) {
        expect(result.data).not.toHaveProperty('upstreamBranch');
      }
    });
  });
});
