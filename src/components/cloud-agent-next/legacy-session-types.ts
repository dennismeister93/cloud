/**
 * Legacy Session Types
 *
 * Types and conversion functions for viewing legacy/V1 session data.
 * New sessions use OpenCode Part[] format (see types.ts).
 */

import type { Images } from '@/lib/images-schema';
import type { ToolExecution } from './types';

// ============================================================================
// Legacy Streaming Message Types
// ============================================================================

/**
 * Cloud agent message (V1 format)
 * Represents all types of messages in the chat (user, assistant, system)
 * Used for viewing legacy sessions in the session viewer.
 */
export type CloudMessage = {
  ts: number; // Timestamp (unique ID for message)
  type: 'user' | 'assistant' | 'system'; // Message role
  say?: string; // Say subtype (text, completion_result, api_req_started, etc.)
  ask?: string; // Ask subtype (tool, command, use_mcp_tool, etc.)
  text?: string; // Message content
  content?: string; // Alternative content field (stream uses both)
  partial?: boolean; // Streaming status (true = still streaming)
  metadata?: Record<string, unknown>; // Additional metadata from stream
  toolExecutions?: ToolExecution[]; // Attached tool executions (for completion messages)
  images?: Images; // Image attachments for the message
};

// ============================================================================
// Legacy Streaming Event Types (from cloud-agent)
// ============================================================================

/**
 * Raw Kilocode CLI event - preserved exactly as received from stdout JSON.
 * These events come directly from the Kilocode CLI and may contain any fields.
 */
export type KilocodeEvent = Record<string, unknown>;

/**
 * System events use streamEventType discriminator to avoid collision with Kilocode's type field.
 * These are internal events generated by the streaming infrastructure.
 */
export type SystemStatusEvent = {
  streamEventType: 'status';
  message: string;
  timestamp: string;
  sessionId?: string;
};

export type SystemOutputEvent = {
  streamEventType: 'output';
  content: string;
  source: 'stdout' | 'stderr';
  timestamp: string;
  sessionId?: string;
};

export type SystemErrorEvent = {
  streamEventType: 'error';
  error: string;
  details?: unknown;
  timestamp: string;
  sessionId?: string;
};

export type SystemCompleteEvent = {
  streamEventType: 'complete';
  sessionId: string;
  exitCode: number;
  metadata: {
    executionTimeMs: number;
    workspace: string;
    userId: string;
    startedAt: string;
    completedAt: string;
  };
};

export type SystemKilocodeEvent = {
  streamEventType: 'kilocode';
  payload: KilocodeEvent;
  sessionId?: string;
};

export type SystemInterruptedEvent = {
  streamEventType: 'interrupted';
  reason: string;
  timestamp: string;
  sessionId?: string;
};

/**
 * Union of all SSE streaming event types (legacy format for server-side integrations).
 * All events use streamEventType discriminator - Kilocode CLI events are wrapped in SystemKilocodeEvent.
 * Used for viewing legacy sessions in the session viewer.
 */
export type StreamEvent =
  | SystemKilocodeEvent
  | SystemStatusEvent
  | SystemOutputEvent
  | SystemErrorEvent
  | SystemCompleteEvent
  | SystemInterruptedEvent;

// ============================================================================
// Legacy Message Conversion
// ============================================================================

/**
 * Convert database message format to CloudMessage format.
 *
 * Used for viewing legacy sessions in the admin panel and session viewer.
 * Database messages (from R2 ui_messages blob) have a different structure
 * than the CloudMessage type used for streaming/display.
 *
 * CLI messages use:
 * - type: 'say' with say: 'user_feedback' for user messages
 * - type: 'say' with other say values for assistant messages
 * - type: 'ask' for system messages asking for input
 *
 * @param dbMessages - Messages from the database/R2
 * @returns Array of CloudMessage objects
 */
export function convertToCloudMessages(dbMessages: Array<Record<string, unknown>>): CloudMessage[] {
  if (!Array.isArray(dbMessages)) {
    return [];
  }

  const shouldParseTextMetadata = (ask?: string, say?: string) =>
    ask === 'tool' ||
    ask === 'use_mcp_tool' ||
    ask === 'command' ||
    say === 'api_req_started' ||
    say === 'tool';

  const parseTextMetadata = (rawText?: string): Record<string, unknown> | undefined => {
    if (!rawText) return undefined;
    const trimmed = rawText.trim();
    if (!trimmed.startsWith('{') || !trimmed.endsWith('}')) return undefined;
    try {
      const parsed = JSON.parse(rawText);
      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
        return parsed as Record<string, unknown>;
      }
    } catch {
      return undefined;
    }
    return undefined;
  };

  return dbMessages
    .map((msg): CloudMessage | null => {
      // Get timestamp
      const ts = msg.ts as number | undefined;
      const timestampStr = msg.timestamp as string | undefined;
      const timestamp = ts || (timestampStr ? new Date(timestampStr).getTime() : Date.now());

      // Get message content
      const text = (msg.text as string) || (msg.content as string) || '';
      const content = (msg.content as string) || (msg.text as string) || '';
      const say = msg.say as string | undefined;
      const ask = msg.ask as string | undefined;
      // Preserve the partial value from DB (default to false if not present)
      const partial = (msg.partial as boolean | undefined) ?? false;
      const rawMetadata = msg.metadata;
      const parsedStringMetadata =
        typeof rawMetadata === 'string' ? parseTextMetadata(rawMetadata) : undefined;
      let metadata =
        rawMetadata && typeof rawMetadata === 'object' && !Array.isArray(rawMetadata)
          ? (rawMetadata as Record<string, unknown>)
          : parsedStringMetadata;

      if (!metadata && shouldParseTextMetadata(ask, say)) {
        const rawText =
          typeof msg.text === 'string' ? msg.text : (msg.content as string | undefined);
        metadata = parseTextMetadata(rawText);
      }

      // Determine message type from various formats
      const rawType = msg.type as string | undefined;
      const rawRole = msg.role as string | undefined;

      let messageType: 'user' | 'assistant' | 'system';

      // Handle CLI extension format (type: 'say' | 'ask')
      if (rawType === 'say') {
        // CLI 'say' messages - check the say field for user_feedback
        if (say === 'user_feedback') {
          messageType = 'user';
        } else {
          messageType = 'assistant';
        }
      } else if (rawType === 'ask') {
        // CLI 'ask' messages - these are assistant messages asking for input
        messageType = 'assistant';
      } else if (rawType === 'user' || rawRole === 'user') {
        messageType = 'user';
      } else if (rawType === 'assistant' || rawRole === 'assistant') {
        messageType = 'assistant';
      } else if (rawType === 'system' || rawRole === 'system') {
        messageType = 'system';
      } else {
        // Default to assistant for unknown types
        messageType = 'assistant';
      }

      return {
        ts: timestamp,
        type: messageType,
        say,
        ask,
        text,
        content,
        partial,
        metadata,
      };
    })
    .filter((msg): msg is CloudMessage => msg !== null);
}
